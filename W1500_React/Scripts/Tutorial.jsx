
// 测试组件 Comment
var Comment = React.createClass({

	// 这里使用 Remarkable， 根据 markdown 语法， 产生 HTML .
	rawMarkup: function() {
		var md = new Remarkable();
		var rawMarkup = md.render(this.props.children.toString());
		return { __html: rawMarkup };
	},


	// 组件的显示.
	render: function() {
		return (
			<div className="comment">
				<h2 className="commentAuthor">
					{this.props.author}
				</h2>
				<span dangerouslySetInnerHTML={this.rawMarkup()} />
			</div>
		);
	}
});



// 测试组件 CommentList
var CommentList = React.createClass({

	// 组件的显示.
	render: function() {

		// 遍历当前的组件的 data 属性, 调用 Comment 组件， 产生内容。
		var commentNodes = this.props.data.map(function(comment) {
			return (
				<Comment author={comment.Author} key={comment.Id}>
					{comment.Text}
				</Comment>
			);
		});

		return (
			<div className="commentList">
			{commentNodes}
			</div>
		);
	}
});



// 测试组件 CommentForm
var CommentForm = React.createClass({

	// 状态数据初始化.
	getInitialState: function() {
		return {author: '', text: ''};
	},

	// 输入框事件处理.
	handleAuthorChange: function(e) {
		this.setState({author: e.target.value});
	},
	// 输入框事件处理.
	handleTextChange: function(e) {
		this.setState({text: e.target.value});
	},
	// 提交事件处理.
	handleSubmit: function(e) {
		e.preventDefault();
		var author = this.state.author.trim();
		var text = this.state.text.trim();
		if (!text || !author) {
			return;
		}
		
		// 提交的处理， 由父组件操作。
		this.props.onCommentSubmit({Author: author, Text: text});

		// 清空输入框.
		this.setState({author: '', text: ''});
	},



	// 组件的显示.
	render: function() {
		return (
			<form className="commentForm" onSubmit={this.handleSubmit}>
				<input
					type="text"
					placeholder="Your name"
					value={this.state.author}
					onChange={this.handleAuthorChange}
				/>
				<input
					type="text"
					placeholder="Say something..."
					value={this.state.text}
					onChange={this.handleTextChange}
				/>

				<input type="submit" value="Post" />
			</form>
		);
	}
});




// 测试组件 CommentBox.
// 该组件使用了 CommentList 与 CommentForm
// 该组件在使用 CommentList 的时候， 将自身的 data 状态的值， 传递给子组件 CommentList.
var CommentBox = React.createClass({

	// 从服务器加载数据.
	loadCommentsFromServer: function() {
		// 定义请求.
		var xhr = new XMLHttpRequest();

		// GET 方式，向 url 属性中的地址提交.
		xhr.open('get', this.props.url, true);

		// 处理事件.
		xhr.onload = function() {
			// 解析结果的 json 字符串为 js 对象.
			var data = JSON.parse(xhr.responseText);
			// 设置状态数据.
			this.setState({ data: data });
		}.bind(this);

		// 发送请求.
		xhr.send();
	},


	// 向服务器提交数据.
	handleCommentSubmit: function(comment) {

		var comments = this.state.data;
		// Optimistically set an id on the new comment. It will be replaced by an
		// id generated by the server. In a production application you would likely
		// not use Date.now() for this and would have a more robust system in place.
		comment.id = Date.now();
		var newComments = comments.concat([comment]);
		this.setState({data: newComments});


		var data = new FormData();
		data.append('Author', comment.Author);
		data.append('Text', comment.Text);

		// 定义请求.
		var xhr = new XMLHttpRequest();
		// POST 方式，向 submitUrl 属性中的地址提交.
		xhr.open('post', this.props.submitUrl, true);
		// 处理完毕后，重新加载数据.
		xhr.onload = function() {
			this.loadCommentsFromServer();
		}.bind(this);

		// 发送请求.
		xhr.send(data);
	},


	// 状态数据初始化.
	getInitialState: function() {
		return {data: []};
	},


	// 在第一次渲染后调用，只在客户端。
	componentWillMount: function() {
		
		// 从服务器加载数据.
		this.loadCommentsFromServer();

		// 每隔固定时间， 重新再加载数据.
		window.setInterval(this.loadCommentsFromServer, this.props.pollInterval);

	},



	// 组件的显示.
	// 传递给 CommentList 组件的  属性 data = 本组件的 状态 data.
	render: function() {
		return (
			<div className="commentBox">
				<h1>Comments</h1>
				
				<CommentList data={this.state.data} />

				<CommentForm onCommentSubmit={this.handleCommentSubmit} />
			</div>
		);
	}
});








// 最终展示.
// 展示的组件， 是 CommentBox， 传递的属性， 是 url = "/Home/Comments"  pollInterval=2000
ReactDOM.render(
	<CommentBox 
		url="/Home/Comments" 
		submitUrl="/Home/AddComment"
		pollInterval={2000} 
	/>,
	document.getElementById('content')
);

